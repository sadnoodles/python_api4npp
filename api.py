# -*- coding: utf-8 -*-
"""
write by: sadnoodles
email: sadnoodles@gmail.com (Please use Chinese if you know it else English.)
Use to generate python autocomplete api.
read the doc and comments. 
If you just want use it ,modify the values at the end of this file.under 'if __name__=="__main__":'.
Then you can generate your own api.
"""
import re
# s=open('python-2.7.api','r').read()
import jinja2
from jinja2 import Template  #jinja is a Template engine, and it is good.

tmp='tmp.xml'  # template file for jinja use. you need not change it.
out='python.xml'    #output file
t=Template(open(tmp,'r').read())
dict={
"api":set(),
"functions":[]
}  #this dict for render Template, do not change.

functions={}

def adda():
#add api in file a 
    """read api in file a.py.It is generated by generate_python_autocomplete.py
    This file is from Internet.See the file for detail.
    """
    import a 
    keys = a.bigdict.keys()
    keys.sort()
    for key in keys:
        v=a.bigdict[key]
        if not any(v):
            dict['api'].add(key)
        else:
            functions[key]={
             'name':key,
             'returnVal':'',
             'doc':a.bigdict[key][2].replace('"',"'"),
             'para':a.bigdict[key][0]
            }

#add api in python-2.7api

def read_api(fname='Python-2.7.api'):
    "read api in Python-2.7.api split is into two file .one is keywords,the other is functions"
    example=open(fname,'r').read()
    fb=open('b.txt','w')
    fc=open('c.txt','w')
    l=[]
    u=set()
    for line in example.splitlines():
        if "(" in line and ")" in line and not("(??)" in line):
            fc.write(line+'\n')
            continue
        a=re.split('[\(\ \-]',line.strip())[0]
        l.append(a)
        u.add(a.split('.')[0])
    l.extend(list(u))
    for i in l:
        fb.write(i+'\n')
    fb.close()
    fc.close()
# read_api()

def addb(fname='b.txt'):
    'read api in file b.txt'
    s=open(fname,'r').read().splitlines()
    for i in s:
        dict['api'].add(i)

def getpare(line,pare='()'):
    "get first () couple"
    count=0
    st=-1
    for n,i in enumerate(line):
        if i==pare[0]:
            if count==0:st=n 
            count+=1
        elif i==pare[1]:
            count-=1
        if st!=-1 and count==0:
            ed=n
            break
    return st,ed
            
def addc(fname='c.txt'):
    "read api in file c.txt"
    s=open(fname,'r').read().splitlines()
    for line in s:
        line=line.replace('"',"'")
        st,ed=getpare(line)
        name=line[:st]
        argv=line[st+1:ed].split(',')
        doc=line[ed+1:]
        fun=functions.get(name,None)
        if not fun:
            functions[name]={
             'name':name,
             'returnVal':'',
             'doc':doc,
             'para':argv
            }
        else:
            if not fun.get('para',None):
                functions[name]['para']=argv
            if not fun.get('returnVal',None):
                functions[name]['returnVal']=doc
        
def add_import(name,withname=False,alias="",fromlist=[],usetail=True):
    """
    name:name for module .
    withname:if you want always use the module name, make it True .
    alias:if you want use some name to replace the module name. someon likes use "import numpy as np".
            np is alias
    fromlist: Like use "from os import path".then name="os" ,fromlist=['path',]
    usetail:you want use 'os.path' or just 'path'. 'path' is tail
    """
    dict['api'].add(name)
    if fromlist:
        a=__import__(name,fromlist=fromlist)
        objs=[a.__getattribute__(x) for x in fromlist]
        if alias:
            dict['api'].add(alias)
            name=alias
        for i in range(len(objs)):
            if usetail:
                name=fromlist[i]
            else:
                name=name+'.'+fromlist[i]
            dict['api'].add(name)
            for j in dir(objs[i]):
                if withname:
                    j=(name+'.'+j)
                dict['api'].add(j)
        del a
        del objs
        return
    onBoard=__import__(name) #fromlist 导入一个name下的module列表
    belongs=dir(onBoard)
    if alias:
        dict['api'].add(alias)
        name=alias
    if usetail:
        name=name.split('.')[-1]
    for j in belongs:
        if withname:
            j=(name+'.'+j)
        dict['api'].add(j)
    onBoard=None
def remove_api(*funs):
    for i in list(dict["api"]):
        for fun in funs:
            if fun(i):
                # print i
                dict["api"].remove(i)
    for k,v in functions.items():
        for fun in funs:
            if fun(k):
                # print k
                functions.pop(k)
if __name__=="__main__":
    
    adda()
    #a is basic
    
    # addb()
    # addc()
    #b,c include more. comment to disable it
    
    # add_import('wx',withname=True)
    # add_import('numpy',withname=True,alias='np')
    # add_import('PyQt4',withname=False,fromlist=["QtCore","QtGui"])
    # add_import('PyQt4.QtCore',withname=True,fromlist=["Qt",],usetail=True)
    # add_import can add some module that you use very often.

    #The more you add, the larger is the  python.xml file .
    #and it will slow down the npp start speed.
    #But its still faster than eclipse and VS.
    
    remove_api(
        lambda x:x.startswith('gen_python_api'),
        lambda x:x.startswith('fcntl'),
        lambda x:x.startswith('ossaudiodev'),
        lambda x:x.count('.')>=3,
        ) #this will remove the api that you dont want,add a filter function to do it.  
    
    #For Processing
    # addb('processing.txt') #comment all python api add*(). and use this two line
    # out='processing.xml'   #will generate processing api
    
    #For Arduino
    # addb('Arduino.txt') #comment all python api add*(). and use this two line
    # out='Arduino.xml'   #will generate Arduino api
    
    #For Python_C_API
    # addb('python_c_API.txt') #comment all python api add*(). and use this two line
    # out='c_py.xml'   #will generate Arduino api
    
    # if you want add other luanguage api just make a file like file a,b,or c,
    # a if a dictionary like. b is just a list. c is a one line function describe.
    
    
    dict['api']=list(dict['api'])
    dict['api'].sort()
    dict['functions']=functions.values()
    dict['functions'].sort(key=lambda x:x['name'])
    open(out,'w').write(t.render(dict))
    # import shutil
    # shutil.copy(out,'E:\Program Files\Notepad++\plugins\APIs\Python.xml')# modify the Notepad++ path.